import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize as opt


class BrakeSystem:
    def __init__(self, params):
        self.params = params
        self.RedP = params['RedP']
        self.a = params['a']
        self.psi = params['psi']
        self.μl = params['μl']
        self.pi = params['pi']
        self.HCG = params['HCG']
        self.μ = params['μ']
        self.FzF = params['FzF']
        self.FzR = params['FzR']
        self.Rdp = params['Rdp']
        self.Dcm = params['Dcm']
        self.Dwc = params['Dwc']
        self.Npast = params['Npast']
        self.atrito_coeficiente = params['atrito_coeficiente']
        self.red = params['red']
        self.Mt = params['Mt']
        self.L = params['L']

    def calculate_params(self, pedal_force):
        BF = 2 * self.μl
        χ = self.HCG / self.L
        W = self.Mt * 9.81
        FzF_dyn = (1 - self.psi + self.a * χ) * W
        FzR_dyn = (self.psi - self.a * χ) * W
        τF = FzF_dyn * self.μ * self.Rdp
        τR = FzR_dyn * self.μ * self.Rdp
        FnF = τF / self.Npast * self.RedP * self.red
        FnR = τR / self.Npast * self.RedP * self.red
        Awc = (self.pi * (self.Dwc ** 2)) / 4
        Acm = (self.pi * (self.Dcm ** 2)) / 4
        PF = FnF / Awc
        PR = FnR / Awc
        FaCM = PF * Acm
        lF = self.psi * self.L
        lR = (1 - self.psi) * self.L
        return BF, χ, W, FzF_dyn, FzR_dyn, τF, τR, FnF, FnR, Awc, Acm, PF, PR, FaCM, lF, lR

    def apply_brake(self, pedal_force):
        resultados = self.calculate_params(pedal_force)
        BF, χ, W, FzF_dyn, FzR_dyn, τF, τR, FnF, FnR, Awc, Acm, PF, PR, FaCM, lF, lR = resultados
        pressao_cilindro_mestre = pedal_force / Acm
        pressao_fluido = pressao_cilindro_mestre
        transmissao_pressao = pressao_fluido * Awc
        forca_aperto_pinca = transmissao_pressao
        forca_atrito_pastilha = forca_aperto_pinca * self.atrito_coeficiente
        torque_disco_freio = forca_atrito_pastilha * self.red
        forca_frenagem = (FnF + FnR) / self.Npast
        forca_frenagem *= self.atrito_coeficiente
        forca_frenagem *= self.red
        forca_frenagem /= self.Rdp

        # Calculando a velocidade angular
        angular_velocity = torque_disco_freio / (self.Mt * self.Rdp ** 2)
        slip_ratio_longitudinal = angular_velocity / (initial_speed / self.Rdp)

        return resultados, forca_frenagem, angular_velocity, slip_ratio_longitudinal


class Dynamics:
    def __init__(self, spring_type, spring_k, spring_F, spring_non_lin_coef, tire_Fz, tire_Sa, tire_Ls):
        self.spring_type = spring_type
        self.spring_k = spring_k
        self.spring_F = spring_F
        self.spring_non_lin_coef = spring_non_lin_coef
        self.tire_Fz = tire_Fz
        self.tire_Sa = tire_Sa
        self.tire_Ls = tire_Ls
        self.tire_type = 'Default'

    def calculate_lateral_slip_ratio(self, v_x, v_y):
        slip_angle = np.arctan2(v_y, v_x)
        return slip_angle

    def Tire(self, params):
        E, Cy, Cx, Cz, c1, c2 = params
        Cs = c1 * np.sin(2 * np.arctan(self.tire_Fz / c2))
        D = 1.5 * self.tire_Fz
        Bz = Cs / (Cz * D)
        Bx = Cs / (Cx * D)
        By = Cs / (Cy * D)
        tire_lateral_force = D * np.sin(
            Cy * np.arctan(By * self.tire_Sa - E * (By * self.tire_Sa - np.arctan(By * self.tire_Sa))))
        tire_auto_align_moment = D * np.sin(
            Cz * np.arctan(Bz * self.tire_Sa - E * (Bz * self.tire_Sa - np.arctan(Bz * self.tire_Sa))))

        return tire_lateral_force, (12 + (tire_auto_align_moment / 58))


# Definindo os parâmetros
params_brake = {
    'RedP': 4,
    'a': 0.8,
    'psi': 0.40,
    'μl': 0.45,
    'pi': 3.14,
    'HCG': 0.5,
    'μ': 0.60,
    'FzF': 1471.5,
    'FzR': 981.0,
    'Rdp': 0.30,
    'Dcm': 0.02,
    'Dwc': 0.032,
    'Npast': 2,
    'atrito_coeficiente': 0.35,
    'red': 0.75,
    'Mt': 250,
    'L': 1.5,
}

# Instanciando as classes
BrakeSystem = BrakeSystem(params_brake)
pedal_force = 445  # N
initial_speed = 20  # m/s (Velocidade inicial do veículo)
resultados, forca_frenagem, angular_velocity, slip_ratio_longitudinal = BrakeSystem.apply_brake(pedal_force)

# Exibindo os resultados calculados
print("Resultados Calculados:")
for i, result in enumerate(resultados):
    print(f"Resultado {i + 1}: {result}")
print("Força de frenagem:", forca_frenagem, "N")
print("Velocidade Angular:", angular_velocity, "rad/s")
print("Slip Ratio Longitudinal:", slip_ratio_longitudinal)

# Dados experimentais para a dinâmica do pneu
angles = np.array(
    [-9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0])
tire_lateral_forces_1 = np.array(
    [-2300, -2200, -2060, -1880, -1680, -1450, -1190, -850, -430, 60, 520, 890, 1170, 1390, 1580, 1730, 1890, 2000,
     2090])
tire_auto_align_moment_1 = np.array(
    [-28.84, -28.68, -27.21, -26.41, -27.70, -24.21, -24.15, -15.88, -4.91, 14.72, 33.80, 43.79, 46.93, 49.09, 50.90,
     50.10, 50.81, 48.12, 48.83])

# Instanciando a classe Dynamics
dynamics_instance = Dynamics(spring_type="Hooke", spring_k=1000, spring_F=500, spring_non_lin_coef=0.1, tire_Fz=1500,
                             tire_Sa=angles, tire_Ls=0.1)

# Exemplo de cálculo do slip ratio lateral
v_x = 20  # Velocidade longitudinal do veículo em m/s
v_y = 2  # Velocidade lateral do veículo em m/s
lateral_slip_ratio = dynamics_instance.calculate_lateral_slip_ratio(v_x, v_y)
print("Slip Ratio Lateral:", lateral_slip_ratio)


# Função de erro total
def total_error(params):
    predicted_tire_lateral_forces, predicted_tire_auto_align_moment = dynamics_instance.Tire(params)
    sq_errors_lateral_force = (predicted_tire_lateral_forces - tire_lateral_forces_1) ** 2
    sq_errors_auto_align_moment = (predicted_tire_auto_align_moment - tire_auto_align_moment_1) ** 2
    total_error = np.sum(sq_errors_lateral_force) + np.sum(sq_errors_auto_align_moment)
    return total_error


# Restrições dos parâmetros
param_bounds = [(-2, 1.2), (1, 3), (1, 3), (1, 3), (1000, 10000), (1, 5000)]

# Minimizando o erro total com restrições nos parâmetros usando busca em grade
result = opt.brute(total_error, param_bounds, finish=None)

# Imprimindo os parâmetros otimizados
print("Parâmetros otimizados:")
print("E:", result[0])
print("Cy:", result[1])
print("Cx:", result[2])
print("Cz:", result[3])
print("c1:", result[4])
print("c2:", result[5])

# Calculando o erro total com os parâmetros otimizados
total_error_optimized = total_error(result)
print("Erro total com parâmetros otimizados:", total_error_optimized)

# Plotagem da curva otimizada com os dados experimentais
predicted_tire_lateral_forces, predicted_tire_auto_align_moment = dynamics_instance.Tire(result)
plt.figure(figsize=(18, 7))  # Definindo um tamanho para a figura

# Plotagem força lateral
plt.subplot(1, 2, 1)
plt.plot(angles, predicted_tire_lateral_forces, label='Curva Otimizada')
plt.scatter(angles, tire_lateral_forces_1, color='red', label='Dados Experimentais')
plt.xlabel('Ângulo de Deslizamento Lateral (graus)')
plt.ylabel('Força Lateral do Pneu (N)')
plt.title('Força Lateral do Pneu - Comparação da Curva Otimizada com os Dados Experimentais')
plt.legend()
plt.grid(True)

# Plotagem torque auto-alinhante
plt.subplot(1, 2, 2)
plt.plot(angles, predicted_tire_auto_align_moment, label='Curva Otimizada')
plt.scatter(angles, tire_auto_align_moment_1, color='blue', label='Dados Experimentais')
plt.xlabel('Ângulo de Deslizamento Lateral (graus)')
plt.ylabel('Torque auto-alinhante (N.m)')
plt.title('Torque Auto-alinhante - Comparação da Curva Otimizada com os Dados Experimentais')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()
